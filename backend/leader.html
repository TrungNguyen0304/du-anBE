<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group Chat with WebRTC - Test Interface</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        #authForm, #groupList, #chatBox, #videoGrid, #callNotification {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 20px;
            background-color: white;
            border-radius: 8px;
        }
        #authForm input {
            padding: 8px;
            margin: 5px;
            width: calc(100% - 20px);
            font-size: 16px;
        }
        #connectButton {
            padding: 8px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #connectButton:hover {
            background-color: #218838;
        }
        #groupList select {
            width: 100%;
            padding: 8px;
            font-size: 16px;
        }
        #videoGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
        }
        video {
            width: 100%;
            max-height: 200px;
            background: black;
            border-radius: 4px;
        }
        #chatMessages {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
        }
        #messageInput {
            width: calc(100% - 90px);
            padding: 8px;
        }
        #sendMessage, #startCall, #cancelCall, #startScreenShare, #stopScreenShare, #selectFile, #joinCall {
            padding: 8px 15px;
            margin: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #sendMessage:hover, #startCall:hover, #cancelCall:hover, #startScreenShare:hover, #stopScreenShare:hover, #selectFile:hover, #joinCall:hover {
            background-color: #0056b3;
        }
        #status, #callNotification {
            margin-top: 10px;
            color: #333;
        }
        #callNotification {
            background-color: #e7f3fe;
            border-color: #b6d4fe;
        }
        #callNotification button {
            background-color: #28a745;
        }
        #callNotification button:hover {
            background-color: #218838;
        }
        .typing-indicator {
            font-style: italic;
            color: #666;
        }
        .message {
            margin: 5px 0;
        }
        .message .sender {
            font-weight: bold;
        }
        #connectionStatus {
            color: #d33;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Group Chat with WebRTC - Test Interface</h1>

        <!-- Authentication Form -->
        <div id="authForm">
            <h3>Enter Credentials</h3>
            <input type="text" id="userIdInput" placeholder="Enter User ID">
            <input type="text" id="groupIdInput" placeholder="Enter Group ID">
            <input type="text" id="tokenInput" placeholder="Enter Token">
            <button id="connectButton" onclick="connect()">Connect</button>
            <div id="connectionStatus"></div>
        </div>

        <!-- Call Notification -->
        <div id="callNotification" style="display: none;">
            <span id="callNotificationText"></span>
            <button id="joinCall" onclick="joinCall()">Join Call</button>
        </div>

        <!-- Group Selection -->
        <div id="groupList">
            <h3>Select or Enter Group</h3>
            <select id="groupSelect" onchange="joinGroup()">
                <option value="">Select a group</option>
            </select>
        </div>

        <!-- Video Grid -->
        <div id="videoGrid"></div>

        <!-- Chat Box -->
        <div id="chatBox">
            <h3>Group Chat</h3>
            <div id="chatMessages"></div>
            <input type="text" id="messageInput" placeholder="Type a message..." onkeypress="handleTyping(event)">
            <button id="sendMessage" onclick="sendMessage()">Send</button>
            <div id="status"></div>
        </div>

        <!-- Call and Screen Share Controls -->
        <div>
            <button id="startCall" onclick="startCall()">Start Video Call</button>
            <button id="cancelCall" onclick="cancelCall()" style="display: none;">Cancel Video Call</button>
            <button id="startScreenShare" onclick="startScreenShare()">Start Screen Share</button>
            <button id="stopScreenShare" onclick="stopScreenShare()" style="display: none;">Stop Screen Share</button>
            <input type="file" id="fileInput" style="display: none;" onchange="startFileTransfer()">
            <button id="selectFile" onclick="document.getElementById('fileInput').click()">Share File</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // Configuration
        let socket = null;
        let userId = null;
        let currentGroupId = null;
        let token = null;
        let localStream = null;
        let screenStream = null;
        const peerConnections = new Map(); // userId -> RTCPeerConnection
        const videoElements = new Map(); // userId -> video element
        let isInCall = false;
        let isScreenSharing = false;

        // WebRTC Configuration
        const servers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        };

        // Connect to Socket.IO and Initialize
        function connect() {
            userId = document.getElementById('userIdInput').value.trim();
            currentGroupId = document.getElementById('groupIdInput').value.trim();
            token = document.getElementById('tokenInput').value.trim();
            const connectionStatus = document.getElementById('connectionStatus');

            if (!userId || !currentGroupId || !token) {
                connectionStatus.textContent = 'Please enter User ID, Group ID, and Token';
                return;
            }

            // Initialize Socket.IO
            socket = io('http://localhost:8001', {
                auth: { token }
            });

            socket.on('connect', () => {
                connectionStatus.textContent = 'Connected to server';
                connectionStatus.style.color = '#28a745';
                socket.emit('user-online', userId);
                joinGroup();
                fetchGroups();
            });

            socket.on('connect_error', (err) => {
                connectionStatus.textContent = `Connection failed: ${err.message}`;
            });

            // Setup Socket.IO event listeners
            setupSocketEvents();
        }

        // Fetch Groups
        async function fetchGroups() {
            try {
                const response = await fetch('http://localhost:8001/api/group', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Failed to fetch groups');
                const groups = await response.json();
                const select = document.getElementById('groupSelect');
                select.innerHTML = '<option value="">Select a group</option>';
                groups.forEach(group => {
                    const option = document.createElement('option');
                    option.value = group._id;
                    option.textContent = group.name;
                    select.appendChild(option);
                });
                select.value = currentGroupId;
            } catch (err) {
                document.getElementById('connectionStatus').textContent = `Error fetching groups: ${err.message}`;
            }
        }

        // Join Group
        async function joinGroup() {
            const select = document.getElementById('groupSelect');
            const selectedGroupId = select.value;
            if (selectedGroupId) {
                currentGroupId = selectedGroupId;
            }
            if (!currentGroupId || !userId) return;

            socket.emit('join-group', { userId, groupId: currentGroupId });
            await fetchMessages();
            updateCallStatus();
            document.getElementById('connectionStatus').textContent = `Joined group ${currentGroupId}`;
        }

        // Fetch Messages
        async function fetchMessages() {
            if (!currentGroupId) return;
            try {
                const response = await fetch(`http://localhost:8001/api/group/${currentGroupId}/messages`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Failed to fetch messages');
                const messages = await response.json();
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.innerHTML = '';
                messages.forEach(msg => {
                    const div = document.createElement('div');
                    div.className = 'message';
                    div.innerHTML = `<span class="sender">${msg.senderName}:</span> ${msg.message || msg.fileName}`;
                    chatMessages.appendChild(div);
                });
                chatMessages.scrollTop = chatMessages.scrollHeight;
            } catch (err) {
                document.getElementById('status').textContent = `Error fetching messages: ${err.message}`;
            }
        }

        // Send Message
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            if (!message || !currentGroupId) return;

            try {
                const response = await fetch(`http://localhost:8001/api/group/${currentGroupId}/message`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ message })
                });
                if (!response.ok) throw new Error('Failed to send message');
                input.value = '';
            } catch (err) {
                document.getElementById('status').textContent = `Error sending message: ${err.message}`;
            }
        }

        // Handle Typing
        function handleTyping(event) {
            if (event.key === 'Enter') {
                sendMessage();
                return;
            }
            socket.emit('typing', { userId, groupId: currentGroupId });
        }

        // Start Video Call
        async function startCall() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                addVideoStream(userId, localStream, 'You');

                const response = await fetch(`http://localhost:8001/api/group/${currentGroupId}/call`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Failed to start call');

                socket.emit('start-call', {
                    groupId: currentGroupId,
                    userId,
                    offer: await createOffer(userId)
                });

                isInCall = true;
                document.getElementById('startCall').style.display = 'none';
                document.getElementById('cancelCall').style.display = 'inline-block';
            } catch (err) {
                document.getElementById('status').textContent = `Error starting call: ${err.message}`;
            }
        }

        // Cancel Video Call
        function cancelCall() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            for (const [id, pc] of peerConnections) {
                if (!id.includes('-screen')) {
                    pc.close();
                    peerConnections.delete(id);
                    const video = videoElements.get(id);
                    if (video) {
                        video.parentElement.remove();
                        videoElements.delete(id);
                    }
                }
            }
            socket.emit('end-call', { groupId: currentGroupId, userId });
            isInCall = false;
            document.getElementById('startCall').style.display = 'inline-block';
            document.getElementById('cancelCall').style.display = 'none';
            document.getElementById('callNotification').style.display = 'none';
            updateCallStatus();
        }

        // Join Call
        async function joinCall() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                addVideoStream(userId, localStream, 'You');

                socket.emit('start-call', {
                    groupId: currentGroupId,
                    userId,
                    offer: await createOffer(userId)
                });

                isInCall = true;
                document.getElementById('startCall').style.display = 'none';
                document.getElementById('cancelCall').style.display = 'inline-block';
                document.getElementById('callNotification').style.display = 'none';
            } catch (err) {
                document.getElementById('status').textContent = `Error joining call: ${err.message}`;
            }
        }

        // Start Screen Share
        async function startScreenShare() {
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                addVideoStream(`${userId}-screen`, screenStream, 'Your Screen');

                const response = await fetch(`http://localhost:8001/api/group/${currentGroupId}/screen-share`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Failed to start screen share');

                socket.emit('start-screen-share', {
                    groupId: currentGroupId,
                    userId,
                    offer: await createOffer(userId, true)
                });

                isScreenSharing = true;
                document.getElementById('startScreenShare').style.display = 'none';
                document.getElementById('stopScreenShare').style.display = 'inline-block';
            } catch (err) {
                document.getElementById('status').textContent = `Error starting screen share: ${err.message}`;
            }
        }

        // Stop Screen Share
        function stopScreenShare() {
            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
            }
            const screenId = `${userId}-screen`;
            const pc = peerConnections.get(screenId);
            if (pc) {
                pc.close();
                peerConnections.delete(screenId);
                const video = videoElements.get(screenId);
                if (video) {
                    video.parentElement.remove();
                    videoElements.delete(screenId);
                }
            }
            socket.emit('stop-screen-share', { groupId: currentGroupId, userId });
            isScreenSharing = false;
            document.getElementById('startScreenShare').style.display = 'inline-block';
            document.getElementById('stopScreenShare').style.display = 'none';
            updateCallStatus();
        }

        // Start File Transfer
        async function startFileTransfer() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file || !currentGroupId) return;

            try {
                const response = await fetch(`http://localhost:8001/api/group/${currentGroupId}/file-transfer`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ fileName: file.name, fileSize: file.size })
                });
                if (!response.ok) throw new Error('Failed to start file transfer');
                const { fileId } = await response.json();

                const chunkSize = 16 * 1024;
                const reader = new FileReader();
                let offset = 0;

                reader.onload = (e) => {
                    socket.emit('file-data', {
                        groupId: currentGroupId,
                        userId,
                        toUserId: 'ALL',
                        fileId,
                        chunk: e.target.result
                    });
                    offset += chunkSize;
                    if (offset < file.size) {
                        readSlice(offset);
                    }
                };

                function readSlice(o) {
                    const slice = file.slice(offset, o + chunkSize);
                    reader.readAsArrayBuffer(slice);
                }

                readSlice(0);
            } catch (err) {
                document.getElementById('status').textContent = `Error starting file transfer: ${err.message}`;
            }
        }

        // Create Offer
        async function createOffer(targetUserId, isScreenShare = false) {
            const pc = new RTCPeerConnection(servers);
            peerConnections.set(targetUserId + (isScreenShare ? '-screen' : ''), pc);

            const stream = isScreenShare ? screenStream : localStream;
            stream.getTracks().forEach(track => pc.addTrack(track, stream));

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', {
                        groupId: currentGroupId,
                        userId,
                        candidate: event.candidate,
                        toUserId: targetUserId
                    });
                }
            };

            pc.ontrack = (event) => {
                addVideoStream(targetUserId + (isScreenShare ? '-screen' : ''), event.streams[0], isScreenShare ? `${targetUserId}'s Screen` : targetUserId);
            };

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            return offer;
        }

        // Add Video Stream
        function addVideoStream(id, stream, name) {
            if (videoElements.has(id)) return;

            const video = document.createElement('video');
            video.srcObject = stream;
            video.autoplay = true;
            video.muted = id === userId || id === `${userId}-screen`;
            video.id = id;

            const videoContainer = document.createElement('div');
            videoContainer.innerHTML = `<strong>${name}</strong>`;
            videoContainer.appendChild(video);

            document.getElementById('videoGrid').appendChild(videoContainer);
            videoElements.set(id, video);
        }

        // Update Call Status
        async function updateCallStatus() {
            if (!currentGroupId) return;
            try {
                const response = await fetch(`http://localhost:8001/api/group/${currentGroupId}/call-status`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Failed to fetch call status');
                const status = await response.json();
                document.getElementById('status').textContent = 
                    `Call: ${status.isCallActive ? 'Active' : 'Inactive'} | Screen Share: ${status.isScreenShareActive ? 'Active' : 'Inactive'} | Participants: ${status.participants.map(p => p.userName).join(', ')}`;
            } catch (err) {
                document.getElementById('status').textContent = `Error fetching call status: ${err.message}`;
            }
        }

        // Setup Socket.IO Event Listeners
        function setupSocketEvents() {
            socket.on('group-message', (data) => {
                const chatMessages = document.getElementById('chatMessages');
                const div = document.createElement('div');
                div.className = 'message';
                div.innerHTML = `<span class="sender">${data.senderName}:</span> ${data.message}`;
                chatMessages.appendChild(div);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });

            socket.on('typing', (data) => {
                document.getElementById('status').textContent = `${data.userId} is typing...`;
                setTimeout(() => {
                    if (document.getElementById('status').textContent.includes('is typing')) {
                        document.getElementById('status').textContent = '';
                    }
                }, 2000);
            });

            socket.on('new-member', (data) => {
                const status = document.getElementById('status');
                status.textContent = `${data.memberName} ${data.isLeaving ? 'left' : 'joined'} the group`;
                setTimeout(() => status.textContent = '', 3000);
                updateCallStatus();
            });

            socket.on('call-started', async (data) => {
                if (data.userId === userId) return;

                if (!isInCall) {
                    document.getElementById('callNotification').style.display = 'block';
                    document.getElementById('callNotificationText').textContent = `${data.userName} started a video call in the group`;
                }

                const pc = new RTCPeerConnection(servers);
                peerConnections.set(data.userId, pc);

                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit('ice-candidate', {
                            groupId: currentGroupId,
                            userId,
                            candidate: event.candidate,
                            toUserId: data.userId
                        });
                    }
                };

                pc.ontrack = (event) => {
                    addVideoStream(data.userId, event.streams[0], data.userName);
                };

                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                socket.emit('call-answer', {
                    groupId: currentGroupId,
                    userId,
                    answer,
                    toUserId: data.userId
                });

                updateCallStatus();
            });

            socket.on('call-answer', async (data) => {
                const pc = peerConnections.get(data.userId);
                if (pc) {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                }
            });

            socket.on('ice-candidate', async (data) => {
                const pc = peerConnections.get(data.userId);
                if (pc && data.candidate) {
                    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            });

            socket.on('call-ended', (data) => {
                const pc = peerConnections.get(data.userId);
                if (pc) {
                    pc.close();
                    peerConnections.delete(data.userId);
                    const video = videoElements.get(data.userId);
                    if (video) {
                        video.parentElement.remove();
                        videoElements.delete(data.userId);
                    }
                }
                document.getElementById('callNotification').style.display = 'none';
                updateCallStatus();
            });

            socket.on('screen-share-started', async (data) => {
                if (data.userId === userId) return;

                const pc = new RTCPeerConnection(servers);
                peerConnections.set(`${data.userId}-screen`, pc);

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit('ice-candidate', {
                            groupId: currentGroupId,
                            userId,
                            candidate: event.candidate,
                            toUserId: data.userId
                        });
                    }
                };

                pc.ontrack = (event) => {
                    addVideoStream(`${data.userId}-screen`, event.streams[0], `${data.userName}'s Screen`);
                };

                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                socket.emit('call-answer', {
                    groupId: currentGroupId,
                    userId,
                    answer,
                    toUserId: data.userId
                });

                updateCallStatus();
            });

            socket.on('screen-share-stopped', (data) => {
                const pc = peerConnections.get(`${data.userId}-screen`);
                if (pc) {
                    pc.close();
                    peerConnections.delete(`${data.userId}-screen`);
                    const video = videoElements.get(`${data.userId}-screen`);
                    if (video) {
                        video.parentElement.remove();
                        videoElements.delete(`${data.userId}-screen`);
                    }
                }
                updateCallStatus();
            });

            socket.on('file-transfer', (data) => {
                const chatMessages = document.getElementById('chatMessages');
                const div = document.createElement('div');
                div.className = 'message';
                div.innerHTML = `<span class="sender">${data.senderId}:</span> Shared file ${data.fileName} (${(data.fileSize / 1024).toFixed(2)} KB)`;
                chatMessages.appendChild(div);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });

            socket.on('file-data', (data) => {
                console.log(`Received file chunk for ${data.fileId}`);
            });
        }
    </script>
</body>
</html>